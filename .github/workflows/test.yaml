name: Monorepo CI/CD (Robust)

on:
  push:
    branches: [main]
  pull_request:

jobs:
  # -----------------------------------------------------------
  # 1. CHANGES & MATRIX
  # -----------------------------------------------------------
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has_changes: ${{ steps.set-matrix.outputs.has_changes }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            api: ['services/api/**', 'services/common/**']
            worker: ['services/worker/**', 'services/common/**']
            frontend: ['services/frontend/**']
      
      # (Hier derselbe Matrix-Code wie vorher, der JSON baut)
      - id: set-matrix
        run: |
           # ... Logik um JSON zu bauen ...
           # Beispiel Output: {"include": [{"service":"api", "type":"python"}, ...]}

  # -----------------------------------------------------------
  # 2. UNIT TESTS (Parallel per Matrix)
  # -----------------------------------------------------------
  unit-tests:
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v4
      # Setup Python/Node je nach matrix.type
      # Run Unit Tests (pytest / npm run test:unit)
      # WICHTIG: Hier wird NICHT gepusht! Nur getestet.

  # -----------------------------------------------------------
  # 3. DER GATEKEEPER: SYSTEM INTEGRATION TEST
  # Hier fangen wir den Fehler "Backend API geändert, Frontend bricht" ab.
  # -----------------------------------------------------------
  system-integration-test:
    needs: [unit-tests] # Wartet, bis ALLE Unit Tests grün sind
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      # Wir nutzen Docker Compose, um das GANZE System hochzufahren
      - name: Start Full Stack
        run: docker-compose -f docker-compose.test.yml up -d --build

      - name: Wait for Services
        run: sleep 15 # oder ein Healthcheck-Script

      # Jetzt läuft ein ECHTER Request vom Frontend Container gegen das Backend
      # Oder wir nutzen ein Tool wie Cypress / Playwright oder ein Python-Script
      - name: Run E2E Check
        run: |
          # Beispiel: Ein Script, das prüft, ob das Frontend noch lädt 
          # und Daten vom Backend bekommt.
          ./scripts/run-smoke-tests.sh
          
      - name: Dump Logs on Failure
        if: failure()
        run: docker-compose logs

  # -----------------------------------------------------------
  # 4. BUILD & PUSH (Parallel)
  # Läuft nur, wenn der System-Test erfolgreich war!
  # -----------------------------------------------------------
  build-and-push:
    needs: [detect-changes, system-integration-test]
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v4
      - uses: docker/login-action@v3
        with:
            registry: ghcr.io
            username: ${{ github.actor }}
            password: ${{ secrets.GITHUB_TOKEN }}
            
      # Hier wird das Image final gebaut und gepusht
      - uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.path }}
          push: true
          tags: ghcr.io/${{ github.repository }}/${{ matrix.service }}:latest